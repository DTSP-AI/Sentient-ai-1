"use strict";
/// <reference types="@cloudflare/workers-types" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PulseSubscription = void 0;
const client_1 = __importDefault(require("@prisma/client"));
const data_types_js_1 = require("./data-types.js");
const errors_js_1 = require("./errors.js");
class PulseSubscription {
    #controller = new AbortController();
    #model;
    #waitForBackoff = Promise.resolve();
    #ws;
    constructor(init) {
        const { endpoint, apiKey, model, modelName, where } = init;
        this.#model = model;
        this.#ws = this.#reconnect(endpoint, [], {
            headers: {
                authorization: `Bearer ${apiKey}`,
                subscription: JSON.stringify({
                    model,
                    modelName,
                    where,
                }),
                stream: JSON.stringify(init.stream),
                "prisma-client-version": client_1.default.Prisma.prismaVersion.client,
            },
        });
    }
    get open() {
        return this.#ws.then((ws) => {
            if (ws.readyState === WebSocket.OPEN) {
                // If the connection is already open, return to avoid a Promise that never resolves.
                // Docs: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
                return Promise.resolve();
            }
            return new Promise((resolve, reject) => {
                ws.addEventListener("open", () => resolve(), { once: true });
                ws.addEventListener("error", (e) => reject(e.error), { once: true });
            });
        });
    }
    async *[Symbol.asyncIterator]() {
        const { signal } = this.#controller;
        while (!signal.aborted) {
            await this.#waitForBackoff;
            const webSocket = await this.#ws;
            const stream = createWebSocketStream(webSocket, signal);
            for await (const event of stream) {
                const json = typeof event === "string" ? event : new TextDecoder().decode(event);
                const wireEvent = (0, data_types_js_1.parsePulseWireEvent)(json);
                // TODO: We have to ack before processing the event. Putting this after the yield does not work.
                // Code after the yield is only run when the consumer calls .next() again.
                // Hence the ack would only happen once the next event arrives.
                await this.acknowledgeEvent(wireEvent.id);
                yield (0, data_types_js_1.convertWireEventToPulseEvent)(wireEvent, this.#model);
            }
        }
    }
    async acknowledgeEvent(id) {
        const msg = { type: "ack", id };
        const webSocket = await this.#ws;
        webSocket.send(JSON.stringify(msg));
    }
    stop() {
        this.#controller.abort();
    }
    async #reconnect(url, protocols, requestInit) {
        const { signal } = this.#controller;
        // initiate a WebSocket request using the Workers fetch approach
        const request = new Request(url.href, requestInit);
        request.headers.set("Upgrade", "websocket");
        request.headers.set("Sec-WebSocket-Extensions", "permessage-deflate");
        request.headers.set("Sec-WebSocket-Protocol", protocols.join(","));
        const response = await fetch(request);
        const { webSocket } = response;
        if (response.status !== 101 || !webSocket) {
            const body = await response.text().catch(() => "");
            throw errors_js_1.PrismaPulseError.fromResponse(response.status, body);
        }
        // accept the WebSocket
        webSocket.accept();
        // close the WebSocket when stop() is called
        signal.addEventListener("abort", () => webSocket.close());
        webSocket.addEventListener("close", async (e) => {
            if (this.#controller.signal.aborted) {
                // PulseSubscription was stopped
                return;
                // TODO: reason codes from server
            }
            else if (e.reason === "GOAWAY") {
                // server told us not to reconnect
                return;
            }
            else {
                // attempt to reconnect on a new WebSocket
                // TODO: do we need a backoff? what should it be? we need to wait in the iterator too
                this.#waitForBackoff = wait(500, signal);
                await this.#waitForBackoff;
                this.#reconnect(url, protocols, requestInit);
            }
        });
        return webSocket;
    }
}
exports.PulseSubscription = PulseSubscription;
function createWebSocketStream(webSocket, signal) {
    return new ReadableStream({
        start(controller) {
            webSocket.addEventListener("close", () => controller.close(), {
                once: true,
                signal,
            });
            webSocket.addEventListener("error", (e) => controller.error(e.error), {
                signal,
            });
            webSocket.addEventListener("message", (d) => controller.enqueue(d.data), {
                signal,
            });
            signal?.addEventListener("abort", () => controller.close(), {
                once: true,
            });
        },
    });
}
function wait(duration, signal) {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(resolve, duration);
        signal.addEventListener("abort", () => clearTimeout(timeout));
        signal.addEventListener("abort", () => reject("aborted"));
    });
}
